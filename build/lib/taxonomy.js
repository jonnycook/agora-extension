// Generated by CoffeeScript 1.10.0
define(['underscore', 'text!taxonomySrc'], function(_, taxonomySrc) {
  var canonicalTypeName, currentItem, i, j, len, len1, line, lines, matches, nameMap, obj, plural, ref, special, synonym, taxonomy, type;
  lines = taxonomySrc.split(/\n/);
  taxonomy = {};
  currentItem = null;
  for (i = 0, len = lines.length; i < len; i++) {
    line = lines[i];
    if (line.trim() === '') {
      continue;
    }
    if (line[0] === '\t') {
      line = line.trim();
      if (line[0] === '#') {
        continue;
      }
      if (line[0] === '@') {
        special = line.match(/^@(.*)\s/)[1];
        if (special === 'icon') {
          taxonomy[currentItem].icon = line.match(/^@icon (.*)$/)[1];
        }
      } else {
        taxonomy[currentItem].properties.push(line);
      }
    } else {
      matches = line.match(/^(.*?)(?: \((.*?)\))?(?: : (.*?))?$/);
      currentItem = matches[1];
      taxonomy[currentItem] = {
        properties: []
      };
      if (matches[2]) {
        taxonomy[currentItem].synonyms = matches[2].split(', ');
      }
      if (matches[3]) {
        taxonomy[currentItem].isA = matches[3];
      }
    }
  }
  nameMap = {};
  plural = function(word) {
    if (word.match(/ly$/)) {
      return word.substr(0, word.length - 1) + 'ies';
    } else if (word.match(/s$/)) {
      return word + 'es';
    } else {
      return word + 's';
    }
  };
  for (type in taxonomy) {
    obj = taxonomy[type];
    nameMap[type] = type;
    nameMap[plural(type)] = type;
    if (obj.synonyms) {
      ref = obj.synonyms;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        synonym = ref[j];
        nameMap[synonym] = type;
        nameMap[plural(synonym)] = type;
      }
    }
  }
  canonicalTypeName = function(typeName) {
    if (typeName) {
      typeName = typeName.toLowerCase();
    }
    return nameMap[typeName];
    if (taxonomy[typeName]) {
      return typeName;
    } else {
      for (type in taxonomy) {
        obj = taxonomy[type];
        if (obj.synonyms && _.contains(obj.synonyms, typeName)) {
          return type;
        }
      }
      return typeName;
    }
  };
  return {
    properties: function(typeName) {
      var k, len2, prop, properties, ref1, results;
      typeName = canonicalTypeName(typeName);
      if (!taxonomy[typeName]) {
        return [];
      }
      properties = [];
      while (typeName) {
        type = taxonomy[typeName];
        if (type.properties) {
          properties = properties.concat((function() {
            var k, len2, ref1, results;
            ref1 = type.properties;
            results = [];
            for (k = 0, len2 = ref1.length; k < len2; k++) {
              prop = ref1[k];
              results.push([typeName, prop]);
            }
            return results;
          })());
        }
        typeName = type.isA;
      }
      properties.sort(function(a, b) {
        if (a[1] > b[1]) {
          return 1;
        } else if (a[1] < b[1]) {
          return -1;
        } else {
          return 0;
        }
      });
      results = [];
      for (k = 0, len2 = properties.length; k < len2; k++) {
        ref1 = properties[k], typeName = ref1[0], prop = ref1[1];
        results.push(typeName + "." + prop);
      }
      return results;
    },
    icon: function(typeName) {
      var ref1;
      return (ref1 = taxonomy[canonicalTypeName(typeName)]) != null ? ref1.icon : void 0;
    }
  };
});

//# sourceMappingURL=taxonomy.js.map
