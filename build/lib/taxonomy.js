// Generated by CoffeeScript 1.7.1
define(['underscore', 'text!taxonomySrc'], function(_, taxonomySrc) {
  var canonicalTypeName, currentItem, line, lines, matches, nameMap, obj, plural, special, synonym, taxonomy, type, _i, _j, _len, _len1, _ref;
  lines = taxonomySrc.split(/\n/);
  taxonomy = {};
  currentItem = null;
  for (_i = 0, _len = lines.length; _i < _len; _i++) {
    line = lines[_i];
    if (line.trim() === '') {
      continue;
    }
    if (line[0] === '\t') {
      line = line.trim();
      if (line[0] === '#') {
        continue;
      }
      if (line[0] === '@') {
        special = line.match(/^@(.*)\s/)[1];
        if (special === 'icon') {
          taxonomy[currentItem].icon = line.match(/^@icon (.*)$/)[1];
        }
      } else {
        taxonomy[currentItem].properties.push(line);
      }
    } else {
      matches = line.match(/^(.*?)(?: \((.*?)\))?(?: : (.*?))?$/);
      currentItem = matches[1];
      taxonomy[currentItem] = {
        properties: []
      };
      if (matches[2]) {
        taxonomy[currentItem].synonyms = matches[2].split(', ');
      }
      if (matches[3]) {
        taxonomy[currentItem].isA = matches[3];
      }
    }
  }
  nameMap = {};
  plural = function(word) {
    if (word.match(/ly$/)) {
      return word.substr(0, word.length - 1) + 'ies';
    } else if (word.match(/s$/)) {
      return word + 'es';
    } else {
      return word + 's';
    }
  };
  for (type in taxonomy) {
    obj = taxonomy[type];
    nameMap[type] = type;
    nameMap[plural(type)] = type;
    if (obj.synonyms) {
      _ref = obj.synonyms;
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        synonym = _ref[_j];
        nameMap[synonym] = type;
        nameMap[plural(synonym)] = type;
      }
    }
  }
  canonicalTypeName = function(typeName) {
    if (typeName) {
      typeName = typeName.toLowerCase();
    }
    return nameMap[typeName];
    if (taxonomy[typeName]) {
      return typeName;
    } else {
      for (type in taxonomy) {
        obj = taxonomy[type];
        if (obj.synonyms && _.contains(obj.synonyms, typeName)) {
          return type;
        }
      }
      return typeName;
    }
  };
  return {
    properties: function(typeName) {
      var prop, properties, _k, _len2, _ref1, _results;
      typeName = canonicalTypeName(typeName);
      if (!taxonomy[typeName]) {
        return [];
      }
      properties = [];
      while (typeName) {
        type = taxonomy[typeName];
        if (type.properties) {
          properties = properties.concat((function() {
            var _k, _len2, _ref1, _results;
            _ref1 = type.properties;
            _results = [];
            for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
              prop = _ref1[_k];
              _results.push([typeName, prop]);
            }
            return _results;
          })());
        }
        typeName = type.isA;
      }
      properties.sort(function(a, b) {
        if (a[1] > b[1]) {
          return 1;
        } else if (a[1] < b[1]) {
          return -1;
        } else {
          return 0;
        }
      });
      _results = [];
      for (_k = 0, _len2 = properties.length; _k < _len2; _k++) {
        _ref1 = properties[_k], typeName = _ref1[0], prop = _ref1[1];
        _results.push("" + typeName + "." + prop);
      }
      return _results;
    },
    icon: function(typeName) {
      var _ref1;
      return (_ref1 = taxonomy[canonicalTypeName(typeName)]) != null ? _ref1.icon : void 0;
    }
  };
});

//# sourceMappingURL=taxonomy.map
