// Generated by CoffeeScript 1.7.1
define(['models/Product', 'models/ProductVariant', 'models/Composite', 'model/Table', 'model/Database', 'model/ModelManager', 'Site', 'model/ObservableArray', 'model/auxiliary/maintainOrder', 'model/HasManyRelationship', 'util'], function(Product, ProductVariant, Composite, Table, Database, ModelManager, Site, ObservableArray, maintainOrder, HasManyRelationship, util) {
  return function(background) {
    var addElementType, db, forProducts, isObjectInShoppingBar, isProductInShoppingBar, map, modelManager;
    map = function(record) {
      switch (record.element_type) {
        case 'Product':
          return 'products';
        case 'ProductVariant':
          return 'product_variants';
        case 'Decision':
          return 'decisions';
        case 'Composite':
          return 'composites';
        case 'Bundle':
          return 'bundles';
        case 'Session':
          return 'sessions';
        case 'List':
          return 'lists';
        case 'Descriptor':
          return 'descriptors';
        case 'ObjectReference':
          return 'object_references';
      }
    };
    db = new Database;
    db.schema = 1;
    modelManager = new ModelManager(db, background);
    addElementType = function(args) {
      var fields, graph, lc, model, parentKey, parentTable, referents, relationships, table, types, _ref;
      if (args.hasParent == null) {
        args.hasParent = true;
      }
      table = parentKey = parentTable = model = null;
      if (args["for"]) {
        lc = args["for"].toLowerCase();
        table = "" + lc + "_elements";
        if (args.hasParent) {
          parentKey = "" + lc + "_id";
        }
        parentTable = "" + lc + "s";
        model = "" + args["for"] + "Element";
      }
      if (args.table) {
        table = args.table;
      }
      if (args.parentKey) {
        parentKey = args.parentKey;
      }
      if (args.parentTable) {
        parentTable = args.parentTable;
      }
      if (args.model) {
        model = args.model;
      }
      types = {
        element_id: 'id',
        element_type: 'string',
        index: 'int',
        creator_id: 'id'
      };
      if (args.hasParent) {
        types[parentKey] = 'id';
      }
      if (args.types) {
        _.extend(types, args.types);
      }
      referents = {
        element_id: map
      };
      if (args.hasParent) {
        referents[parentKey] = parentTable;
      }
      fields = [];
      if (args.hasParent) {
        fields.push(parentKey);
      }
      graph = {
        element_id: {
          table: function(record) {
            return map(record._values);
          },
          owns: function(record) {
            var _ref;
            return !((_ref = record.table.name) === 'products' || _ref === 'product_variants');
          }
        }
      };
      if (args.graph) {
        _.extend(graph, args.graph);
      }
      if (args.hasParent) {
        graph[parentKey] = {
          table: parentTable,
          owner: true
        };
      }
      db.addTable(table, {
        schema: {
          fields: fields,
          types: types,
          referents: referents,
          opts: {
            element_id: {
              reassignIdentical: true
            },
            element_type: {
              reassignIdentical: true
            }
          }
        },
        graph: graph
      });
      relationships = {
        element: {
          type: 'hasOne',
          relKey: 'element_id',
          model: function(instance) {
            return instance.get('element_type');
          }
        }
      };
      if (args.hasParent) {
        relationships.parent = {
          type: 'hasOne',
          relKey: parentKey,
          model: (_ref = args.parentModel) != null ? _ref : args["for"]
        };
      }
      return modelManager.addModel(model, {
        orderBy: args.orderBy,
        table: table,
        relationships: relationships
      });
    };
    db.addTable('users', {
      schema: {
        types: {
          tutorial_step: 'int',
          user_colors: 'string',
          tutorials: 'string',
          email: 'string',
          alerts_email: 'string'
        },
        defaultValues: {
          tutorial_step: 0
        }
      },
      onGraph: true
    });
    db.addTable('collaborators', {
      schema: {
        types: {
          object: 'string',
          object_user_id: 'id',
          user_id: 'id',
          active: 'bool'
        },
        defaultValues: {
          active: false
        }
      }
    });
    db.addTable('products', {
      schema: {
        fields: ['image', 'title', 'price', 'reviews', 'sem3_id', 'coupons'],
        local: ['sem3_id', 'coupons', 'inShoppingBar'],
        types: {
          inShoppingBar: 'object',
          more: 'object',
          offers: 'object',
          offer: 'object',
          retrievalId: 'string',
          rating: 'float',
          ratingCount: 'int',
          last_scraped_at: 'int',
          scraper_version: 'string',
          status: 'int',
          price: 'string'
        },
        defaultValues: {
          purchased: false
        },
        opts: {
          more: {
            reassignIdentical: true
          }
        }
      },
      graph: {
        canBeExternal: false
      }
    });
    db.addTable('product_variants', {
      schema: {
        types: {
          variant: 'object'
        },
        referents: {
          product_id: 'products'
        },
        defaultValues: {
          schema_version: 0
        }
      },
      graph: {
        canBeExternal: false
      }
    });
    db.addTable('product_watches', {
      schema: {
        local: ['listing', 'stock', 'used', 'new', 'refurbished', 'state'],
        types: {
          watch_threshold: 'int',
          watch_increment: 'int',
          watch_condition: 'int',
          enable_threshold: 'bool',
          enable_stock: 'bool',
          enable_increment: 'bool',
          index: 'int',
          seen: 'bool',
          enabled: 'bool',
          state: 'int',
          reported_stock: 'int',
          reported_listing: 'int',
          reported_new: 'int',
          reported_used: 'int',
          reported_refurbished: 'int',
          initial_stock: 'int',
          initial_listing: 'int',
          initial_new: 'int',
          initial_used: 'int',
          initial_refurbished: 'int',
          stock: 'int',
          listing: 'int',
          "new": 'int',
          used: 'int',
          refurbished: 'int',
          stock: 'int'
        },
        defaultValues: {
          enable_threshold: false,
          enable_increment: false,
          enable_stock: false,
          watch_condition: 0,
          enabled: true
        },
        referents: {
          product_id: 'products'
        }
      }
    });
    db.addTable('site_settings', {
      schema: {
        fields: ['site', 'enabled'],
        types: {
          enabled: 'int'
        }
      }
    });
    db.addTable('bundles', {
      graph: {
        root_elements: {
          field: 'element_id',
          owner: true,
          filter: function(record, otherRecord) {
            return map(otherRecord._values) === record.table.name;
          }
        },
        bundle_elements: [
          {
            field: 'element_id',
            owner: true,
            filter: function(record, otherRecord) {
              return map(otherRecord._values) === record.table.name;
            }
          }, {
            field: 'bundle_id',
            owns: true
          }
        ],
        list_elements: {
          field: 'element_id',
          owner: true,
          filter: function(record, otherRecord) {
            return map(otherRecord._values) === record.table.name;
          }
        },
        session_elements: {
          field: 'element_id',
          owner: true,
          filter: function(record, otherRecord) {
            return map(otherRecord._values) === record.table.name;
          }
        },
        belt_elements: {
          field: 'element_id',
          owner: true,
          filter: function(record, otherRecord) {
            return map(otherRecord._values) === record.table.name;
          }
        }
      }
    });
    db.addTable('competitive_lists');
    db.addTable('lists', {
      schema: {
        types: {
          descriptor: 'object'
        },
        defaultValues: {
          collapsed: false
        }
      },
      graph: {
        list_elements: {
          field: 'list_id',
          owns: true
        },
        decisions: {
          field: 'list_id',
          owner: true
        }
      }
    });
    db.addTable('belts', {
      schema: {
        types: {
          title: 'string',
          shared: 'bool'
        },
        referents: {
          user_id: 'users'
        }
      },
      graph: {
        belt_elements: {
          field: 'belt_id',
          owns: true
        }
      }
    });
    db.addTable('composites');
    db.addTable('composite_slots', {
      schema: {
        types: {
          index: 'int',
          composite_id: 'id',
          element_id: 'id',
          element_type: 'string'
        },
        referents: {
          element_id: map,
          composite_id: 'composites'
        },
        opts: {
          element_id: {
            reassignIdentical: true
          }
        }
      }
    });
    db.addTable('sessions', {
      schema: {
        types: {
          title: 'string'
        },
        defaultValues: {
          collapsed: false
        }
      },
      graph: {
        session_elements: {
          field: 'session_id',
          owns: true
        },
        root_elements: {
          field: 'element_id',
          owner: true,
          filter: function(record, otherRecord) {
            return map(otherRecord._values) === record.table.name;
          }
        },
        belt_elements: {
          field: 'element_id',
          owner: true,
          filter: function(record, otherRecord) {
            return map(otherRecord._values) === record.table.name;
          }
        }
      }
    });
    db.addTable('decisions', {
      schema: {
        referents: {
          list_id: 'lists'
        },
        types: {
          display_options: 'object',
          share_title: 'string',
          share_message: 'string',
          shared: 'bool',
          access: 'int'
        },
        defaultValues: {
          access: 0
        },
        opts: {
          display_options: {
            reassignIdentical: true
          }
        }
      },
      graph: {
        list_id: {
          table: 'lists',
          owns: true
        },
        decision_elements: {
          field: 'decision_id',
          owns: true
        },
        root_elements: {
          field: 'element_id',
          owner: true,
          filter: function(record, otherRecord) {
            return map(otherRecord._values) === record.table.name;
          }
        },
        bundle_elements: {
          field: 'element_id',
          owner: true,
          filter: function(record, otherRecord) {
            return map(otherRecord._values) === record.table.name;
          }
        },
        list_elements: {
          field: 'element_id',
          owner: true,
          filter: function(record, otherRecord) {
            return map(otherRecord._values) === record.table.name;
          }
        },
        session_elements: {
          field: 'element_id',
          owner: true,
          filter: function(record, otherRecord) {
            return map(otherRecord._values) === record.table.name;
          }
        },
        belt_elements: {
          field: 'element_id',
          owner: true,
          filter: function(record, otherRecord) {
            return map(otherRecord._values) === record.table.name;
          }
        }
      }
    });
    db.addTable('object_references', {
      schema: {
        types: {
          object_user_id: 'id',
          object: 'string'
        }
      },
      graph: {
        root_elements: {
          field: 'element_id',
          owner: true,
          filter: function(record, otherRecord) {
            return map(otherRecord._values) === record.table.name;
          }
        },
        bundle_elements: {
          field: 'element_id',
          owner: true,
          filter: function(record, otherRecord) {
            return map(otherRecord._values) === record.table.name;
          }
        },
        list_elements: {
          field: 'element_id',
          owner: true,
          filter: function(record, otherRecord) {
            return map(otherRecord._values) === record.table.name;
          }
        },
        session_elements: {
          field: 'element_id',
          owner: true,
          filter: function(record, otherRecord) {
            return map(otherRecord._values) === record.table.name;
          }
        },
        belt_elements: {
          field: 'element_id',
          owner: true,
          filter: function(record, otherRecord) {
            return map(otherRecord._values) === record.table.name;
          }
        }
      }
    });
    db.addTable('decision_elements', {
      schema: {
        types: {
          row: 'int'
        },
        defaultValues: {
          row: 0,
          selected: false,
          dismissed: false
        },
        referents: {
          decision_id: 'decisions',
          list_element_id: 'list_elements'
        }
      },
      graph: {
        decision_id: {
          table: 'decisions',
          owner: true
        }
      }
    });
    db.addTable('data', {
      schema: {
        types: {
          type: 'string',
          url: 'string',
          title: 'string',
          text: 'string',
          comment: 'string',
          element_type: 'string'
        },
        referents: {
          element_id: map
        }
      }
    });
    db.addTable('feelings', {
      schema: {
        types: {
          positive: 'int',
          negative: 'int',
          thought: 'string',
          element_type: 'string',
          timestamp: 'datetime'
        },
        referents: {
          element_id: map
        }
      },
      graph: {
        onGraph: true
      }
    });
    db.addTable('arguments', {
      schema: {
        types: {
          "for": 'int',
          against: 'int',
          thought: 'string',
          element_type: 'string',
          timestamp: 'datetime'
        },
        referents: {
          element_id: map
        }
      }
    });
    db.addTable('descriptors', {
      schema: {
        types: {
          descriptor: 'object',
          element_type: 'string'
        },
        referents: {
          element_id: map
        },
        opts: {
          element_id: {
            reassignIdentical: true
          }
        }
      }
    });
    db.addTable('shared_objects', {
      schema: {
        types: {
          object: 'string',
          title: 'string',
          user_id: 'id',
          with_user_id: 'id',
          user_name: 'string',
          with_user_name: 'string',
          seen: 'bool'
        }
      }
    });
    db.addTable('activity', {
      schema: {
        types: {
          user_id: 'id',
          generator_id: 'id',
          timestamp: 'int',
          type: 'string',
          object_type: 'string',
          object_id: 'id',
          args: 'object'
        }
      }
    });
    addElementType({
      "for": 'Root',
      parentKey: 'user_id',
      parentTable: 'users',
      parentModel: 'User'
    });
    addElementType({
      "for": 'Collection',
      hasParent: false,
      orderBy: {
        field: 'index',
        direction: 'asc'
      }
    });
    addElementType({
      "for": 'Session'
    });
    addElementType({
      "for": 'Composite'
    });
    addElementType({
      "for": 'Bundle'
    });
    addElementType({
      "for": 'CompetitiveList',
      table: 'competitive_list_elements',
      parentKey: 'competitive_list_id',
      parentTable: 'competitive_lists'
    });
    addElementType({
      "for": 'List'
    });
    addElementType({
      "for": 'Belt'
    });
    modelManager.defineModels({
      User: {
        table: 'users',
        relationships: {
          belts: {
            type: 'hasMany',
            model: 'Belt',
            foreignKey: 'user_id'
          },
          rootElements: {
            type: 'hasMany',
            model: 'RootElement',
            foreignKey: 'user_id',
            orderBy: {
              field: 'index',
              direction: 'asc'
            }
          },
          sharedWithMe: {
            type: 'hasMany',
            model: 'SharedObject',
            foreignKey: 'with_user_id'
          },
          unseenSharedWithMe: {
            type: 'hasMany',
            model: 'SharedObject',
            foreignKey: 'with_user_id',
            filter: function(instance) {
              return !instance.get('seen');
            }
          }
        }
      },
      CompetitiveList: {
        table: 'competitive_lists',
        relationships: {
          elements: {
            type: 'hasMany',
            model: 'CompetitiveListElement',
            foreignKey: 'competitive_list_id',
            orderBy: {
              field: 'index',
              direction: 'asc'
            }
          },
          contents: {
            type: 'hasMany',
            through: 'competitive_list_elements',
            foreignKey: 'competitive_list_id',
            relKey: 'element_id',
            orderBy: {
              field: 'index',
              direction: 'asc'
            },
            model: function(record) {
              return record.get('element_type');
            },
            defaultValues: function(instance) {
              return {
                element_type: instance.model.name
              };
            }
          }
        }
      },
      Belt: {
        table: 'belts',
        relationships: {
          elements: {
            type: 'hasMany',
            model: 'BeltElement',
            foreignKey: 'belt_id',
            orderBy: {
              field: 'index',
              direction: 'asc'
            }
          },
          contents: {
            type: 'hasMany',
            through: 'belt_elements',
            foreignKey: 'belt_id',
            relKey: 'element_id',
            orderBy: {
              field: 'index',
              direction: 'asc'
            },
            model: function(record) {
              return record.get('element_type');
            },
            defaultValues: function(instance) {
              return {
                element_type: instance.model.name
              };
            }
          }
        }
      },
      List: {
        table: 'lists',
        relationships: {
          elements: {
            type: 'hasMany',
            model: 'ListElement',
            foreignKey: 'list_id',
            orderBy: {
              field: 'index',
              direction: 'asc'
            }
          },
          contents: {
            type: 'hasMany',
            through: 'list_elements',
            foreignKey: 'list_id',
            relKey: 'element_id',
            orderBy: {
              field: 'index',
              direction: 'asc'
            },
            model: function(record) {
              return record.get('element_type');
            },
            defaultValues: function(instance) {
              return {
                element_type: instance.model.name
              };
            }
          }
        }
      },
      Decision: {
        table: 'decisions',
        relationships: {
          list: {
            type: 'hasOne',
            relKey: 'list_id',
            model: 'List'
          },
          listElements: {
            type: 'hasMany',
            through: 'decision_elements',
            model: 'ListElement',
            foreignKey: 'decision_id',
            relKey: 'list_element_id'
          },
          elements: {
            type: 'hasMany',
            foreignKey: 'decision_id',
            model: 'DecisionElement',
            "for": {
              path: 'list.elements',
              key: 'list_element_id'
            }
          },
          selection: {
            type: 'hasMany',
            through: 'decision_elements',
            throughFilter: function(record) {
              return record.get('selected');
            },
            model: 'ListElement',
            foreignKey: 'decision_id',
            relKey: 'list_element_id',
            remove: function(instance) {
              return this._instance.get('listElements').instanceForInstance(instance).set('selected', false);
            },
            add: function(instance) {
              this._instance.get('listElements').add(instance);
              return this._instance.get('listElements').instanceForInstance(instance).set('selected', true);
            }
          },
          dismissed: {
            type: 'hasMany',
            through: 'decision_elements',
            throughFilter: function(record) {
              return record.get('dismissed');
            },
            model: 'ListElement',
            foreignKey: 'decision_id',
            relKey: 'list_element_id',
            remove: function(instance) {
              return this._instance.get('listElements').instanceForInstance(instance).set('dismissed', false);
            },
            add: function(instance) {
              this._instance.get('listElements').add(instance);
              return this._instance.get('listElements').instanceForInstance(instance).set('dismissed', true);
            }
          },
          considering: {
            type: 'hasMany',
            through: 'decision_elements',
            throughFilter: function(record) {
              return !record.get('dismissed');
            },
            model: 'ListElement',
            foreignKey: 'decision_id',
            relKey: 'list_element_id',
            remove: function(instance) {
              return this._instance.get('listElements').instanceForInstance(instance).set('dismissed', true);
            },
            add: function(instance) {
              this._instance.get('listElements').add(instance);
              return this._instance.get('listElements').instanceForInstance(instance).set('dismissed', false);
            }
          }
        }
      },
      DecisionElement: {
        table: 'decision_elements',
        relationships: {
          element: {
            type: 'hasOne',
            model: 'ListElement',
            relKey: 'list_element_id'
          },
          decision: {
            type: 'hasOne',
            model: 'Decision',
            relKey: 'decision_id'
          }
        }
      },
      Bundle: {
        table: 'bundles',
        relationships: {
          elements: {
            type: 'hasMany',
            model: 'BundleElement',
            foreignKey: 'bundle_id',
            orderBy: {
              field: 'index',
              direction: 'asc'
            }
          },
          contents: {
            type: 'hasMany',
            through: 'bundle_elements',
            relKey: 'element_id',
            foreignKey: 'bundle_id',
            model: function(record) {
              return record.get('element_type');
            },
            defaultValues: function(instance) {
              return {
                element_type: instance.model.name
              };
            },
            orderBy: {
              field: 'index',
              direction: 'asc'
            }
          }
        }
      },
      Descriptor: {
        table: 'descriptors',
        relationships: {
          element: {
            type: 'hasOne',
            relKey: 'element_id',
            model: function(instance) {
              return instance.get('element_type');
            }
          }
        }
      },
      ObjectReference: {
        table: 'object_references'
      },
      CompositeSlot: {
        table: 'composite_slots',
        relationships: {
          element: {
            type: 'hasOne',
            relKey: 'element_id',
            model: function(instance) {
              return instance.get('element_type');
            }
          }
        }
      },
      Composite: {
        "class": Composite,
        table: 'composites',
        relationships: {
          slots: {
            type: 'hasMany',
            foreignKey: 'composite_id',
            model: 'CompositeSlot',
            orderBy: {
              field: 'index',
              direction: 'asc'
            }
          },
          additionalContents: {
            type: 'hasMany',
            through: 'composite_elements',
            foreignKey: 'composite_id',
            relKey: 'element_id',
            model: function(instance) {
              return instance.get('element_type');
            },
            defaultValues: function(instance) {
              return {
                element_type: instance.model.name
              };
            },
            orderBy: {
              field: 'index',
              direction: 'asc'
            }
          },
          additionalElements: {
            type: 'hasMany',
            foreignKey: 'composite_id',
            model: 'CompositeElement',
            orderBy: {
              field: 'index',
              direction: 'asc'
            }
          },
          contents: function(instance) {
            var list, onInstance, rel, _i, _len, _ref;
            list = new ObservableArray;
            onInstance = function(inst) {
              inst.set('index', list.length());
              list.push(inst);
              return maintainOrder({
                field: 'index',
                direction: 'asc'
              }, inst, list);
            };
            _ref = ['slots', 'additionalElements'];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              rel = _ref[_i];
              instance.get(rel).each(onInstance);
              instance.get(rel).observe(function(mutationInfo) {
                var i, _j, _ref1, _ref2, _results;
                if (mutationInfo.type === 'insertion') {
                  return onInstance(mutationInfo.value);
                } else if (mutationInfo.type === 'deletion') {
                  list.remove(mutationInfo.value);
                  if (list.length() > 1) {
                    _results = [];
                    for (i = _j = _ref1 = Math.min(instance.get('index'), list.length() - 1), _ref2 = list.length(); _ref1 <= _ref2 ? _j < _ref2 : _j > _ref2; i = _ref1 <= _ref2 ? ++_j : --_j) {
                      _results.push(list.get(i).set('index', i));
                    }
                    return _results;
                  }
                }
              });
            }
            return {
              add: function(inst) {
                if (inst.model.name === 'CompositeSlot') {
                  return instance.get('slots').add(inst);
                } else {
                  return instance.get('additionalElements').add(inst);
                }
              },
              remove: function(inst) {
                if (inst.model.name === 'CompositeSlot') {
                  return instance.get('slots').remove(inst);
                } else {
                  return instance.get('additionalElements').remove(inst);
                }
              },
              instanceForInstance: function(inst) {
                if (inst.model.name === 'CompositeSlot') {
                  return instance.get('slots').instanceForInstance(inst);
                } else {
                  return instance.get('additionalElements').instanceForInstance(inst);
                }
              },
              observe: function() {
                return list.observe.apply(list, arguments);
              },
              stopObserving: function() {
                return list.stopObserving.apply(list, arguments);
              },
              each: function() {
                return list.each.apply(list, arguments);
              },
              get: function() {
                return list.get.apply(list, arguments);
              }
            };
          }
        }
      },
      Session: {
        table: 'sessions',
        relationships: {
          elements: {
            type: 'hasMany',
            model: 'SessionElement',
            foreignKey: 'session_id',
            orderBy: {
              field: 'index',
              direction: 'asc'
            }
          },
          contents: {
            type: 'hasMany',
            through: 'session_elements',
            foreignKey: 'session_id',
            relKey: 'element_id',
            orderBy: {
              field: 'index',
              direction: 'asc'
            },
            model: function(record) {
              return record.get('element_type');
            },
            defaultValues: function(instance) {
              return {
                element_type: instance.model.name
              };
            }
          }
        }
      },
      Product: {
        "class": Product,
        table: 'products',
        properties: {
          url: function() {
            return "http://agora.sh/product/" + (this._get('siteName')) + "/" + (this.get('productSid'));
          },
          currency: function() {
            if (this._get('currency')) {
              return this._get('currency');
            } else {
              return Site.site(this._get('siteName')).config.currency;
            }
          },
          displayPrice: function() {
            var currencySymbolMap;
            if (this.get('price') === this.model.errorMap.price) {
              return '(error)';
            } else if (this.get('currency') === 'embedded') {
              if (this.get('price') === '') {
                return '(none)';
              } else {
                return this.get('price');
              }
            } else {
              if ((this.get('price') != null) && this.get('currency')) {
                currencySymbolMap = {
                  dollar: '$',
                  euro: 'EUR '
                };
                return "" + currencySymbolMap[this.get('currency')] + (this.get('price'));
              } else {
                return this.get('price');
              }
            }
          },
          displayUserPrice: function() {
            var currencySymbolMap, price;
            if (this.get('currency') === 'embedded') {
              if (this.get('userPrice') === '') {
                return '(none)';
              } else {
                return this.get('userPrice');
              }
            } else {
              if (this.get('offer')) {
                currencySymbolMap = {
                  dollar: '$',
                  euro: 'EUR '
                };
                price = parseFloat(this.get('offer').price).toFixed(2);
                price = util.numberWithCommas(price);
                return "" + currencySymbolMap[this.get('currency')] + price;
              }
            }
          },
          siteUrl: function() {
            if (this._get('siteName') === 'General') {
              return this._get('productSid').split('/').slice(0, 3).join('/');
            } else {
              return Site.site(this._get('siteName')).url;
            }
          },
          siteName: function() {
            var name;
            if (this._get('siteName') === 'General') {
              name = this._get('productSid').split('/')[2];
              if (/^www\./.exec(name)) {
                name = name.substr(4);
              }
              return name;
            } else {
              return this._get('siteName');
            }
          }
        },
        relationships: {
          data: {
            type: 'hasMany',
            model: 'Datum',
            foreignKey: 'element_id',
            filter: function(record) {
              return record.get('element_type') === 'Product';
            }
          },
          feelings: {
            type: 'hasMany',
            model: 'Feeling',
            foreignKey: 'element_id',
            filter: function(record) {
              return record.get('element_type') === 'Product';
            }
          },
          "arguments": {
            type: 'hasMany',
            model: 'Argument',
            foreignKey: 'element_id',
            filter: function(record) {
              return record.get('element_type') === 'Product';
            }
          },
          lists: {
            type: 'hasMany',
            through: 'list_elements',
            model: 'List',
            relKey: 'list_id',
            foreignKey: 'element_id',
            throughFilter: function(record) {
              return record.get('element_type') === 'Product';
            }
          },
          bundles: {
            type: 'hasMany',
            through: 'bundle_elements',
            model: 'Bundle',
            relKey: 'bundle_id',
            foreignKey: 'element_id',
            throughFilter: function(record) {
              return record.get('element_type') === 'Product';
            }
          },
          variants: {
            type: 'hasMany',
            model: 'ProductVariant',
            foreignKey: 'product_id'
          },
          root: {
            type: 'hasMany',
            model: 'RootElement',
            foreignKey: 'element_id',
            filter: function(record) {
              return record.get('element_type') === 'Product';
            }
          }
        }
      },
      ProductVariant: {
        "class": ProductVariant,
        table: 'product_variants',
        relationships: {
          product: {
            type: 'hasOne',
            relKey: 'product_id',
            model: 'Product'
          },
          data: {
            type: 'hasMany',
            model: 'Datum',
            foreignKey: 'element_id',
            filter: function(record) {
              return record.get('element_type') === 'ProductVariant';
            }
          },
          feelings: {
            type: 'hasMany',
            model: 'Feeling',
            foreignKey: 'element_id',
            filter: function(record) {
              return record.get('element_type') === 'ProductVariant';
            }
          },
          "arguments": {
            type: 'hasMany',
            model: 'Argument',
            foreignKey: 'element_id',
            filter: function(record) {
              return record.get('element_type') === 'ProductVariant';
            }
          },
          lists: {
            type: 'hasMany',
            through: 'list_elements',
            model: 'List',
            relKey: 'list_id',
            foreignKey: 'element_id',
            throughFilter: function(record) {
              return record.get('element_type') === 'ProductVariant';
            }
          },
          bundles: {
            type: 'hasMany',
            through: 'bundle_elements',
            model: 'Bundle',
            relKey: 'bundle_id',
            foreignKey: 'element_id',
            throughFilter: function(record) {
              return record.get('element_type') === 'ProductVariant';
            }
          },
          root: {
            type: 'hasMany',
            model: 'RootElement',
            foreignKey: 'element_id',
            filter: function(record) {
              return record.get('element_type') === 'ProductVariant';
            }
          }
        }
      },
      ProductWatch: {
        table: 'product_watches',
        orderBy: {
          field: 'index',
          direction: 'asc'
        },
        relationships: {
          product: {
            type: 'hasOne',
            relKey: 'product_id',
            model: 'Product'
          }
        }
      },
      Datum: {
        table: 'data',
        relationships: {
          element: {
            type: 'hasOne',
            relKey: 'element_id',
            model: function(instance) {
              return instance.get('element_type');
            }
          }
        }
      },
      Feeling: {
        table: 'feelings',
        relationships: {
          element: {
            type: 'hasOne',
            relKey: 'element_id',
            model: function(instance) {
              return instance.get('element_type');
            }
          }
        }
      },
      Argument: {
        table: 'arguments',
        relationships: {
          element: {
            type: 'hasOne',
            relKey: 'element_id',
            model: function(instance) {
              return instance.get('element_type');
            }
          }
        }
      },
      SharedObject: {
        table: 'shared_objects'
      }
    });
    isObjectInShoppingBar = function(obj) {
      var beltElement, beltElements, bundleElement, bundleElements, decision, listElement, listElements, response, _i, _j, _k, _len, _len1, _len2;
      if (beltElements = modelManager.getModel('BeltElement').findAll({
        element_type: obj.modelName,
        element_id: obj.get('id')
      })) {
        if (beltElements.length) {
          response = {};
          for (_i = 0, _len = beltElements.length; _i < _len; _i++) {
            beltElement = beltElements[_i];
            response[beltElement.get('parent').get('user_id')] = true;
          }
          return response;
        }
      }
      listElements = modelManager.getModel('ListElement').findAll({
        element_type: obj.modelName,
        element_id: obj.get('id')
      });
      for (_j = 0, _len1 = listElements.length; _j < _len1; _j++) {
        listElement = listElements[_j];
        decision = modelManager.getModel('Decision').find({
          list_id: listElement.get('list_id')
        });
        if (decision) {
          if (response = isObjectInShoppingBar(decision)) {
            return response;
          }
        }
      }
      bundleElements = modelManager.getModel('BundleElement').findAll({
        element_type: obj.modelName,
        element_id: obj.get('id')
      });
      for (_k = 0, _len2 = bundleElements.length; _k < _len2; _k++) {
        bundleElement = bundleElements[_k];
        if (response = isObjectInShoppingBar(bundleElement.get('parent'))) {
          return response;
        }
      }
      return false;
    };
    isProductInShoppingBar = function(product) {
      var beltElement, beltElements, bundle, decision, i, list, response, _i, _j, _k, _l, _len, _ref, _ref1, _ref2;
      if (beltElements = modelManager.getModel('BeltElement').findAll({
        element_type: 'Product',
        element_id: product.get('id')
      })) {
        if (beltElements.length) {
          response = {};
          for (_i = 0, _len = beltElements.length; _i < _len; _i++) {
            beltElement = beltElements[_i];
            response[beltElement.get('parent').get('user_id')] = true;
          }
          return response;
        }
      }
      for (i = _j = 0, _ref = product.get('lists').length(); 0 <= _ref ? _j < _ref : _j > _ref; i = 0 <= _ref ? ++_j : --_j) {
        list = product.get('lists').get(i);
        decision = modelManager.getModel('Decision').find({
          list_id: list.get('id')
        });
        if (decision) {
          if (response = isObjectInShoppingBar(decision)) {
            return response;
          }
        }
      }
      for (i = _k = 0, _ref1 = product.get('bundles').length(); 0 <= _ref1 ? _k < _ref1 : _k > _ref1; i = 0 <= _ref1 ? ++_k : --_k) {
        bundle = product.get('bundles').get(i);
        if (response = isObjectInShoppingBar(bundle)) {
          return response;
        }
      }
      for (i = _l = 0, _ref2 = product.get('variants').length(); 0 <= _ref2 ? _l < _ref2 : _l > _ref2; i = 0 <= _ref2 ? ++_l : --_l) {
        if (response = isObjectInShoppingBar(product.get('variants').get(i))) {
          return response;
        }
      }
      return false;
    };
    forProducts = function(element, cb) {
      if (element.get('element_type') === 'Product') {
        return cb(element.get('element'));
      } else if (element.get('element_type') === 'ProductVariant') {
        return cb(modelManager.getModel('Product').withId(element.get('element').get('product_id')));
      } else if (element.get('element_type') === 'Decision') {
        return element.get('element').get('list').get('elements').each(function(element) {
          return forProducts(element, cb);
        });
      } else if (element.get('element_type') === 'Bundle') {
        return element.get('element').get('elements').each(function(element) {
          return forProducts(element, cb);
        });
      }
    };
    modelManager.getModel('ListElement').events.onCreate.subscribe(function(instance) {
      return forProducts(instance, function(product) {
        return product.set('inShoppingBar', isProductInShoppingBar(product));
      });
    });
    modelManager.getModel('ListElement').events.onRemove.subscribe(function(instance) {
      return forProducts(instance, function(product) {
        return product.set('inShoppingBar', isProductInShoppingBar(product));
      });
    });
    modelManager.getModel('BundleElement').events.onCreate.subscribe(function(instance) {
      return forProducts(instance, function(product) {
        return product.set('inShoppingBar', isProductInShoppingBar(product));
      });
    });
    modelManager.getModel('BundleElement').events.onRemove.subscribe(function(instance) {
      return forProducts(instance, function(product) {
        return product.set('inShoppingBar', isProductInShoppingBar(product));
      });
    });
    modelManager.getModel('BeltElement').events.onCreate.subscribe(function(instance) {
      return forProducts(instance, function(product) {
        return product.set('inShoppingBar', isProductInShoppingBar(product));
      });
    });
    modelManager.getModel('BeltElement').events.onRemove.subscribe(function(instance) {
      return forProducts(instance, function(product) {
        return product.set('inShoppingBar', isProductInShoppingBar(product));
      });
    });
    return {
      db: db,
      modelManager: modelManager
    };
  };
});

//# sourceMappingURL=init.map
