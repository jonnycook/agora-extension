// Generated by CoffeeScript 1.10.0
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

define(function() {
  return {
    d: ['View', 'util', 'icons'],
    c: function() {
      var AddArgumentView;
      return AddArgumentView = (function(superClass) {
        extend(AddArgumentView, superClass);

        AddArgumentView.prototype.type = 'AddArgument';

        function AddArgumentView() {
          var arugmentEl, parse, positionPreviewEl;
          AddArgumentView.__super__.constructor.apply(this, arguments);
          this.el = this.viewEl('<div class="v-addArgument dark"> <div class="content"> <ul class="arguments"> <li> <span class="position" /> <span class="thought" /> <a href="#" class="delete" /> </li> </ul> <form> <input type="text" name="argument" placeholder="Add argument" autocomplete="off"><span class="positionPreview" /> <!--<input type="submit" value="Add">--> </form> </div> </div>');
          parse = function(argument) {
            var against, char, i, j, k, l, pro, ref, ref1;
            against = 0;
            pro = 0;
            argument = argument.trim();
            for (i = k = 0, ref = argument.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
              char = argument[i];
              if (char === '-') {
                ++against;
              } else if (char === '+') {
                ++pro;
              } else {
                break;
              }
            }
            argument = argument.substr(i);
            for (j = l = ref1 = argument.length - 1; ref1 <= 0 ? l < 0 : l > 0; j = ref1 <= 0 ? ++l : --l) {
              char = argument[j];
              if (char === '-') {
                ++against;
              } else if (char === '+') {
                ++pro;
              } else {
                break;
              }
            }
            argument = argument.substr(0, j + 1).trim();
            return [pro, against, argument];
          };
          arugmentEl = this.el.find('[name=argument]');
          positionPreviewEl = this.el.find('.positionPreview');
          arugmentEl.keydown((function(_this) {
            return function(e) {
              if (e.keyCode === 27) {
                return _this.close(true);
              }
            };
          })(this));
          arugmentEl.keyup((function(_this) {
            return function(e) {
              var against, position, pro, ref;
              ref = parse(arugmentEl.val()), pro = ref[0], against = ref[1];
              position = util.positionClass(pro, against);
              return positionPreviewEl.removeClass().addClass('positionPreview').addClass(position);
            };
          })(this));
          this.el.find('form').submit((function(_this) {
            return function(e) {
              var against, pro, ref, thought;
              e.preventDefault();
              ref = parse(arugmentEl.val()), pro = ref[0], against = ref[1], thought = ref[2];
              _this.callBackgroundMethod('add', [pro, against, thought]);
              _this.el.find('form [name="argument"]').val('');
              setTimeout((function() {
                return _this.close();
              }), 700);
              return false;
            };
          })(this));
        }

        AddArgumentView.prototype.onData = function(data1) {
          var iface;
          this.data = data1;
          iface = this.listInterface(this.el, '.arguments li', (function(_this) {
            return function(el, data, pos, onRemove) {
              var previousPosition, updateForPosition, view;
              view = _this.view();
              onRemove(function() {
                return view.destruct();
              });
              view.valueInterface(el.find('.thought')).setDataSource(data.thought);
              previousPosition = null;
              updateForPosition = function() {
                var position;
                position = util.positionClass(data["for"].get(), data.against.get());
                if (previousPosition) {
                  el.find('.position').removeClass(previousPosition);
                }
                el.find('.position').addClass(position);
                return previousPosition = position;
              };
              data["for"].observe(updateForPosition);
              data.against.observe = updateForPosition;
              updateForPosition();
              el.find('.delete').click(function() {
                _this.callBackgroundMethod('delete', data.id);
                return false;
              });
              return el;
            };
          })(this));
          iface.onInsert = (function(_this) {
            return function() {
              return typeof _this.sizeChanged === "function" ? _this.sizeChanged() : void 0;
            };
          })(this);
          iface.onDelete = (function(_this) {
            return function(el, del) {
              del();
              return typeof _this.sizeChanged === "function" ? _this.sizeChanged() : void 0;
            };
          })(this);
          iface.setDataSource(data);
          return setTimeout(((function(_this) {
            return function() {
              return _this.el.find('[name=argument]').get(0).focus();
            };
          })(this)), 50);
        };

        return AddArgumentView;

      })(View);
    }
  };
});

//# sourceMappingURL=AddArgumentView.js.map
