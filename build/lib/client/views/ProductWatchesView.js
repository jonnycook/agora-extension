// Generated by CoffeeScript 1.10.0
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

define(function() {
  return function() {
    var ProductWatchesView, formatPrice;
    formatPrice = function(price) {
      return "$" + price;
    };
    return ProductWatchesView = (function(superClass) {
      extend(ProductWatchesView, superClass);

      function ProductWatchesView() {
        return ProductWatchesView.__super__.constructor.apply(this, arguments);
      }

      ProductWatchesView.prototype.type = 'ProductWatches';

      ProductWatchesView.prototype.flexibleLayout = true;

      ProductWatchesView.prototype.init = function() {
        this.updateFuncs = [];
        return this.viewEl('<div class="-agora v-productWatches"> <div class="productWatches"> <div class="productWatch hasTarget targetMet"> <a href="#" target="_blank" class="title" /> <a href="#" target="_blank" class="image" /> <div class="meter"> <label class="min" /> <label class="max" /> <label class="currentPrice">current <span class="value" /></label> <div class="diff" /> <div class="targetPrice" /> <div class="initialPrice" /> <div class="currentPrice" /> <label class="targetPrice">target <span class="value" /></label> <label class="initialPrice">initial <span class="value" /></label> </div> </div> </div> </div>');
      };

      ProductWatchesView.prototype.updateLayout = function() {
        var func, i, len, ref, results;
        ref = this.updateFuncs;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          func = ref[i];
          results.push(func());
        }
        return results;
      };

      ProductWatchesView.prototype.onData = function(data) {
        var iface;
        iface = this.listInterface(this.el, '.productWatches .productWatch', (function(_this) {
          return function(el, data, pos, onRemove) {
            var update, view;
            view = _this.view();
            onRemove = function() {
              view.destruct();
              return this.updateFuncs.splice(this.updateFuncs.indexOf(update), 1);
            };
            update = function() {
              var currentPrice, currentPriceEl, currentPricePos, currentPriceWidth, diffEl, initialPrice, initialPriceEl, initialPriceLabel, initialPriceLabelLeft, initialPriceLabelRight, initialPricePos, left, max, meterPos, meterWidth, mid, min, right, targetPrice, targetPriceEl, targetPriceLabel, targetPriceLabelLeft, targetPriceLabelRight, targetPricePos;
              currentPrice = data.currentPrice.get();
              initialPrice = data.initialPrice.get();
              targetPrice = data.targetPrice.get();
              if (currentPrice) {
                el.removeClass('outOfStock');
                currentPriceEl = el.find('div.currentPrice');
                initialPriceEl = el.find('div.initialPrice');
                targetPriceEl = el.find('div.targetPrice');
                diffEl = el.find('.diff');
                meterWidth = el.find('.meter').width();
                min = Math.min(currentPrice, initialPrice, targetPrice);
                min = Math.max(0, min - min * .1);
                max = Math.max(currentPrice, initialPrice, targetPrice) * 1.1;
                el.find('label.min').html(formatPrice(Math.floor(min)));
                el.find('label.max').html(formatPrice(Math.floor(max)));
                currentPricePos = (currentPrice - min) / (max - min) * meterWidth;
                initialPricePos = (initialPrice - min) / (max - min) * meterWidth;
                currentPriceEl.css('left', currentPricePos);
                initialPriceEl.css('left', initialPricePos);
                el.find('label.initialPrice .value').html(formatPrice(initialPrice));
                el.find('label.initialPrice').css({
                  left: initialPricePos - el.find('label.initialPrice').outerWidth() / 2,
                  textAlign: ''
                });
                currentPriceWidth = el.find('label.currentPrice').outerWidth();
                el.find('label.currentPrice .value').html(formatPrice(currentPrice));
                pos = Math.max(el.find('label.min').position().left + el.find('label.min').outerWidth() + 10, Math.min(currentPricePos - currentPriceWidth / 2, el.find('label.max').position().left - 10 - currentPriceWidth));
                el.find('label.currentPrice').css({
                  left: pos
                });
                left = right = 0;
                if (targetPrice) {
                  if (currentPrice <= targetPrice) {
                    el.addClass('targetMet');
                  } else {
                    el.removeClass('targetMet');
                  }
                  targetPricePos = (targetPrice - min) / (max - min) * meterWidth;
                  targetPriceEl.css('left', targetPricePos);
                  el.find('label.targetPrice .value').html(formatPrice(targetPrice));
                  el.find('label.targetPrice').css({
                    left: targetPricePos,
                    marginLeft: -el.find('label.targetPrice').outerWidth() / 2,
                    textAlign: ''
                  });
                  meterPos = el.find('.meter').offset().left;
                  initialPriceLabel = el.find('label.initialPrice');
                  targetPriceLabel = el.find('label.targetPrice');
                  initialPriceLabelLeft = initialPriceLabel.offset().left - meterPos;
                  initialPriceLabelRight = initialPriceLabelLeft + initialPriceLabel.outerWidth();
                  targetPriceLabelLeft = targetPriceLabel.offset().left - meterPos;
                  targetPriceLabelRight = targetPriceLabelLeft + targetPriceLabel.outerWidth();
                  if ((initialPriceLabelLeft < targetPriceLabelRight && initialPriceLabelLeft > targetPriceLabelLeft || initialPriceLabelRight < targetPriceLabelRight && initialPriceLabelRight > targetPriceLabelLeft) || (targetPriceLabelLeft < initialPriceLabelRight && targetPriceLabelLeft > initialPriceLabelLeft || targetPriceLabelRight < initialPriceLabelRight && targetPriceLabelRight > initialPriceLabelLeft)) {
                    mid = (initialPricePos + targetPricePos) / 2;
                    if (initialPrice < targetPrice) {
                      initialPriceLabel.css({
                        left: mid - initialPriceLabel.outerWidth() - 2,
                        marginLeft: 0,
                        textAlign: 'right'
                      });
                      targetPriceLabel.css({
                        left: mid + 2,
                        marginLeft: 0,
                        textAlign: 'left'
                      });
                    } else {
                      targetPriceLabel.css({
                        left: mid - targetPriceLabel.outerWidth() - 2,
                        marginLeft: 0,
                        textAlign: 'right'
                      });
                      initialPriceLabel.css({
                        left: mid + 2,
                        marginLeft: 0,
                        textAlign: 'left'
                      });
                    }
                  }
                  el.addClass('hasTarget');
                  left = Math.min(currentPricePos, targetPricePos);
                  right = Math.max(currentPricePos, targetPricePos);
                } else {
                  el.removeClass('hasTarget');
                  if (currentPrice <= initialPrice) {
                    el.addClass('targetMet');
                  } else {
                    el.removeClass('targetMet');
                  }
                  left = Math.min(initialPricePos, currentPricePos);
                  right = Math.max(initialPricePos, currentPricePos);
                }
                return diffEl.css({
                  left: left,
                  width: right - left
                });
              } else {
                return el.addClass('outOfStock');
              }
            };
            _this.updateFuncs.push(update);
            data.currentPrice.observe(update);
            data.targetPrice.observe(update);
            data.initialPrice.observe(update);
            view.withData(data.image, function(image) {
              return el.find('.image').css('backgroundImage', "url('" + image + "')");
            });
            view.withData(data.title, function(title) {
              return el.find('.title').html(title);
            });
            el.find('.title, .image').attr('href', data.url);
            view.withData(data.state, function(state) {
              if (state) {
                return el.addClass('inited');
              } else {
                return el.removeClass('inited');
              }
            });
            setTimeout(update, 0);
            return el;
          };
        })(this));
        return iface.setDataSource(data.productWatches);
      };

      return ProductWatchesView;

    })(View);
  };
});

//# sourceMappingURL=ProductWatchesView.js.map
