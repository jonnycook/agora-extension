// Generated by CoffeeScript 1.7.1
var __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

define(function() {
  return {
    d: ['View', 'util', 'icons'],
    c: function() {
      var AddFeelingView;
      return AddFeelingView = (function(_super) {
        __extends(AddFeelingView, _super);

        function AddFeelingView() {
          return AddFeelingView.__super__.constructor.apply(this, arguments);
        }

        AddFeelingView.prototype.type = 'AddFeeling';

        AddFeelingView.prototype.init = function(args) {
          var emotionEl, feelingEl, parse;
          if (args == null) {
            args = {};
          }
          this.el = this.viewEl('<div class="v-addFeeling dark"> <div class="content"> <ul class="feelings"> <li> <span class="emotion" /> <span class="thought" /> <a href="#" class="delete" /> </li> </ul> <form> <input type="text" name="feeling" placeholder="Add feeling" autocomplete="off"><span class="emotionSummary neutral" /> <!--<input type="submit" value="Add">--> </form> </div> </div>');
          parse = function(feeling) {
            var char, emotion, emotionWords, i, index, j, map, matchingFeeling, negative, pattern, positive, word, wordList, words, _i, _j, _k, _l, _len, _len1, _ref, _ref1;
            negative = 0;
            positive = 0;
            feeling = feeling.trim();
            for (i = _i = 0, _ref = feeling.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
              char = feeling[i];
              if (char === '-') {
                ++negative;
              } else if (char === '+') {
                ++positive;
              } else {
                break;
              }
            }
            feeling = feeling.substr(i);
            for (j = _j = _ref1 = feeling.length - 1; _ref1 <= 0 ? _j < 0 : _j > 0; j = _ref1 <= 0 ? ++_j : --_j) {
              char = feeling[j];
              if (char === '-') {
                ++negative;
              } else if (char === '+') {
                ++positive;
              } else {
                break;
              }
            }
            feeling = feeling.substr(0, j + 1).trim();
            if (!(negative || positive)) {
              words = {
                "-2": ['hate', 'really dont like', 'terrible', 'disgusting'],
                "-1": ['dont like', 'bad', 'ugly', 'poor', 'stupid', 'dumb', 'shitty', 'stinks', 'nasty', 'wretched', 'low quality', 'sad'],
                "1": ['like', 'cool', 'good', 'nice', 'classy', 'tasteful', 'cute', 'happy'],
                "2": ['love', 'awesome', 'great', 'perfect', 'fantastic', 'wonderful', 'beautiful', 'sensational', 'magical']
              };
              wordList = [];
              map = {};
              for (emotion in words) {
                emotionWords = words[emotion];
                for (_k = 0, _len = emotionWords.length; _k < _len; _k++) {
                  word = emotionWords[_k];
                  map[word] = parseInt(emotion);
                  wordList.push(word);
                }
              }
              wordList.sort(function(a, b) {
                return b.length - a.length;
              });
              matchingFeeling = feeling.replace('\'', '').split(/\s+/).join(' ');
              for (_l = 0, _len1 = wordList.length; _l < _len1; _l++) {
                word = wordList[_l];
                pattern = new RegExp("\\b" + word + "\\b", 'i');
                if ((index = matchingFeeling.search(pattern)) !== -1) {
                  matchingFeeling = matchingFeeling.replace(pattern, '');
                  emotion = map[word];
                  if (emotion < 0) {
                    negative -= emotion;
                  } else if (emotion > 0) {
                    positive += emotion;
                  }
                }
              }
            }
            return [positive, negative, feeling];
          };
          feelingEl = this.el.find('[name=feeling]');
          emotionEl = this.el.find('.emotionSummary');
          feelingEl.keydown((function(_this) {
            return function(e) {
              if (e.keyCode === 27) {
                _this.close(true);
                return e.stopPropagation();
              }
            };
          })(this));
          feelingEl.keyup((function(_this) {
            return function(e) {
              var emotion, negative, positive, _ref;
              if (typeof _this.pin === "function") {
                _this.pin();
              }
              _ref = parse(feelingEl.val()), positive = _ref[0], negative = _ref[1];
              emotion = util.emotionClass(positive, negative);
              return emotionEl.removeClass().addClass('emotionSummary').addClass(emotion);
            };
          })(this));
          return this.el.find('form').submit((function(_this) {
            return function(e) {
              var negative, positive, thought, _ref;
              e.preventDefault();
              _ref = parse(feelingEl.val()), positive = _ref[0], negative = _ref[1], thought = _ref[2];
              if (args.auto) {
                _this.event('add', 'auto');
              } else {
                _this.event('add');
              }
              _this.callBackgroundMethod('add', [positive, negative, thought]);
              _this.el.find('form [name="feeling"]').val('');
              setTimeout((function() {
                return _this.close();
              }), 700);
              return false;
            };
          })(this));
        };

        AddFeelingView.prototype.onData = function(data) {
          var iface;
          this.data = data;
          iface = this.listInterface(this.el, '.feelings li', (function(_this) {
            return function(el, data, pos, onRemove) {
              var previousEmotion, updateForEmotion, view;
              view = _this.view();
              onRemove(function() {
                return view.destruct();
              });
              view.valueInterface(el.find('.thought')).setDataSource(data.thought);
              previousEmotion = null;
              updateForEmotion = function() {
                var emotion;
                emotion = util.emotionClass(data.positive.get(), data.negative.get());
                if (previousEmotion) {
                  el.find('.emotion').removeClass(previousEmotion);
                }
                el.find('.emotion').addClass(emotion);
                return previousEmotion = emotion;
              };
              data.positive.observe(updateForEmotion);
              data.negative.observe = updateForEmotion;
              updateForEmotion();
              el.find('.delete').click(function() {
                _this.event('delete');
                _this.callBackgroundMethod('delete', data.id);
                return false;
              });
              return el;
            };
          })(this));
          iface.onInsert = (function(_this) {
            return function() {
              return typeof _this.sizeChanged === "function" ? _this.sizeChanged() : void 0;
            };
          })(this);
          iface.onDelete = (function(_this) {
            return function(el, del) {
              del();
              return typeof _this.sizeChanged === "function" ? _this.sizeChanged() : void 0;
            };
          })(this);
          iface.setDataSource(data);
          return setTimeout(((function(_this) {
            return function() {
              return _this.el.find('[name=feeling]').get(0).focus();
            };
          })(this)), 50);
        };

        AddFeelingView.prototype.shown = function() {
          this.event('open');
          return _tutorial('AddFeeling', this.el.find('form [name="feeling"]'));
        };

        return AddFeelingView;

      })(View);
    }
  };
});

//# sourceMappingURL=AddFeelingView.map
