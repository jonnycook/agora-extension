// Generated by CoffeeScript 1.7.1
define(function() {
  var DeclarativeScraper, Value;
  Value = (function() {
    function Value(name, value) {
      this.name = name;
      this.value = value;
    }

    return Value;

  })();
  return DeclarativeScraper = (function() {
    DeclarativeScraper.prototype.executeMatches = function(matches, subject) {
      var i, match, values, _i, _len;
      values = [];
      if (matches) {
        for (i = _i = 0, _len = matches.length; _i < _len; i = ++_i) {
          match = matches[i];
          if (match.disabled) {
            continue;
          }
          values = values.concat(this.execute(match, subject, i));
        }
      }
      return values;
    };

    DeclarativeScraper.prototype.getPath = function() {
      var el, _i, _len, _ref, _results;
      _ref = this.path;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        el = _ref[_i];
        _results.push({
          index: el.index,
          type: el.type
        });
      }
      return _results;
    };

    DeclarativeScraper.prototype.hasValue = function(obj, key) {
      return obj && key in obj && obj[key] !== null && obj[key] !== '';
    };

    DeclarativeScraper.prototype.executeMatch = function(el, matches) {
      var capture, group, r, values, _ref;
      values = [];
      if (el.captures) {
        _ref = el.captures;
        for (group in _ref) {
          capture = _ref[group];
          r = this.execute(capture, matches[parseInt(group)], group);
          if (r) {
            values = values.concat(r);
          }
        }
      }
      return this.processValue(el, values, matches);
    };

    DeclarativeScraper.prototype.processValue = function(el, values, matches, tieredMatches, subject) {
      var a, array, content, i, name, obj, part, parts, value, _i, _j, _k, _len, _len1, _len2;
      if (el.value) {
        name = el.value.name;
        if (this.hasValue(el.value, 'name') && matches) {
          name = name.replace(/\$(\d+):(\d+)/g, function(match, p1, p2) {
            return tieredMatches[parseInt(p1)][parseInt(p2)];
          });
          name = name.replace(/\$([a-z]*)(\d+)/g, function(match, flag, p1) {
            var value;
            value = matches[parseInt(p1)];
            if (flag === 'lc') {
              value = value.toLowerCase();
            }
            return value;
          });
        }
        if (this.hasValue(el.value, 'type')) {
          if (el.value.type === 'array') {
            array = [];
            for (_i = 0, _len = values.length; _i < _len; _i++) {
              value = values[_i];
              array.push(value.value);
            }
            return [new Value(name, array)];
          } else if (el.value.type === 'object') {
            obj = {};
            for (_j = 0, _len1 = values.length; _j < _len1; _j++) {
              value = values[_j];
              if (!value.name) {
                console.debug(el, values);
                throw new Error('ValueMustHaveName');
              }
              a = obj;
              parts = value.name.split('.');
              for (i = _k = 0, _len2 = parts.length; _k < _len2; i = ++_k) {
                part = parts[i];
                if (i === parts.length - 1) {
                  a[part] = value.value;
                } else {
                  if (a[part] == null) {
                    a[part] = {};
                  }
                  a = a[part];
                }
              }
            }
            return [new Value(name, obj)];
          }
        } else if (this.hasValue(el.value, 'content')) {
          content = el.value.content;
          if (matches) {
            content = content.replace(/\$(\d+):(\d+)/g, function(match, p1, p2) {
              return tieredMatches[parseInt(p1)][parseInt(p2)].replace(/"/g, '\\"');
            });
            content = content.replace(/\$([a-z]*)(\d+)/g, function(match, flag, p1) {
              value = matches[parseInt(p1)].replace(/"/g, '\\"');
              if (flag === 'lc') {
                value = value.toLowerCase();
              }
              return value;
            });
          }
          return [new Value(name, JSON.parse(content))];
        } else if (matches && this.hasValue(el.value, 'capture')) {
          return [new Value(name, matches[el.value.capture])];
        } else if (this.hasValue(el.value, 'name')) {
          if (values.length) {
            values[0].name = name;
          } else {
            return [new Value(name, subject)];
          }
        }
      }
      return values;
    };

    DeclarativeScraper.prototype.execute = function(el, subject, index) {
      var capture, caseObj, e, globalMatch, globalMatches, group, i, match, matches, regExp, retVal, tieredMatches, value, values, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
      if (index == null) {
        index = 0;
      }
      retVal = null;
      if (el.type || el.pattern) {
        if (el.type == null) {
          el.type = 'Match';
        }
        this.path.push({
          type: 'match',
          index: index,
          el: el
        });
        switch (el.type) {
          case 'Match':
            regExp = new RegExp(el.pattern);
            matches = subject.match(regExp);
            if (matches) {
              values = [];
              if (el.captures) {
                try {
                  _ref = el.captures;
                  for (group in _ref) {
                    capture = _ref[group];
                    values = values.concat(this.execute(capture, matches[parseInt(group)], group));
                  }
                } catch (_error) {
                  e = _error;
                  if (el.optional && e.message === 'FailedRequirement') {
                    retVal = [];
                  } else {
                    throw e;
                  }
                }
              }
              retVal = this.processValue(el, values, matches);
            } else if (el.optional) {
              retVal = [];
            } else {
              throw new Error('FailedRequirement');
            }
            break;
          case 'MatchAll':
            regExp = new RegExp(el.pattern);
            globalMatches = subject.match(new RegExp(el.pattern, 'g'));
            tieredMatches = [];
            if (globalMatches) {
              values = [];
              try {
                for (i = _i = 0, _len = globalMatches.length; _i < _len; i = ++_i) {
                  globalMatch = globalMatches[i];
                  matches = globalMatch.match(regExp);
                  tieredMatches[i] = matches;
                  values = values.concat(this.executeMatch({
                    type: 'Match',
                    captures: el.match.captures,
                    value: el.match.value
                  }, matches));
                }
              } catch (_error) {
                e = _error;
                if (el.optional && e.message === 'FailedRequirement') {
                  retVal = [];
                } else {
                  throw e;
                }
              }
              retVal = this.processValue(el, values, globalMatches, tieredMatches);
            } else if (el.optional) {
              retVal = [];
            } else {
              throw new Error('FailedRequirement');
            }
            break;
          case 'Or':
            _ref1 = el.matches;
            for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
              match = _ref1[i];
              if (match.disabled) {
                continue;
              }
              try {
                value = this.execute(match, subject, i);
                if (value.length) {
                  retVal = this.processValue(el, value, null, null, subject);
                  break;
                }
              } catch (_error) {
                e = _error;
                if (e.message !== 'FailedRequirement') {
                  throw e;
                } else {
                  this.path.pop();
                }
              }
            }
            if (!retVal) {
              if (el.optional) {
                retVal = [];
              } else {
                throw new Error('FailedRequirement');
              }
            }
            break;
          case 'Switch':
            value = null;
            try {
              _ref2 = el.cases;
              for (i = _k = 0, _len2 = _ref2.length; _k < _len2; i = ++_k) {
                caseObj = _ref2[i];
                if (caseObj.disabled) {
                  continue;
                }
                if (this.hasValue(caseObj, 'pattern') && subject.match(new RegExp(caseObj.pattern)) || !this.hasValue(caseObj, 'pattern')) {
                  value = this.processValue(caseObj, this.executeMatches(caseObj.matches, subject), null, null, subject);
                  break;
                }
              }
            } catch (_error) {
              e = _error;
              if (el.optional && e.message === 'FailedRequirement') {
                retVal = [];
              } else {
                throw e;
              }
            }
            value = this.processValue(el, value, null, null, subject);
            if (value.length) {
              retVal = value;
            } else if (el.optional) {
              retVal = [];
            } else {
              throw new Error('FailedRequirement');
            }
            break;
          case 'Count':
            regExp = new RegExp(el.pattern, 'g');
            matches = subject.match(regExp);
            if (matches) {
              retVal = [new Value(null, matches.length)];
            } else {
              retVal = [];
            }
        }
      } else {
        this.path.push({
          type: 'text',
          index: index
        });
        values = this.executeMatches(el.matches, subject);
        retVal = this.processValue(el, values, null, null, subject);
      }
      if (retVal === null) {
        throw new Error('return is null');
      }
      this.path.pop();
      return retVal;
    };

    function DeclarativeScraper(scraper) {
      this.scraper = scraper;
      this.path = [];
    }

    DeclarativeScraper.prototype.scrape = function(subject) {
      return this.execute(this.scraper, subject);
    };

    return DeclarativeScraper;

  })();
});

//# sourceMappingURL=DeclarativeScraper.map
